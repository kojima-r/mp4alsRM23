/***************** MPEG-4 Audio Lossless Coding **************************

This software module was originally developed by

Tilman Liebchen (Technical University of Berlin)

in the course of development of the MPEG-4 Audio standard ISO/IEC 14496-3
and associated amendments. This software module is an implementation of
a part of one or more MPEG-4 Audio lossless coding tools as specified
by the MPEG-4 Audio standard. ISO/IEC gives users of the MPEG-4 Audio
standards free license to this software module or modifications
thereof for use in hardware or software products claiming conformance
to the MPEG-4 Audio standards. Those intending to use this software
module in hardware or software products are advised that this use may
infringe existing patents. The original developer of this software
module, the subsequent editors and their companies, and ISO/IEC have
no liability for use of this software module or modifications thereof
in an implementation. Copyright is not released for non MPEG-4 Audio
conforming products. The original developer retains full right to use
the code for the developer's own purpose, assign or donate the code to
a third party and to inhibit third party from using the code for non
MPEG-4 Audio conforming products. This copyright notice must be included
in all copies or derivative works.

Copyright (c) 2003.

filename : wave.cpp
project  : MPEG-4 Audio Lossless Coding
author   : Tilman Liebchen (Technical University of Berlin)
date     : June 16, 2003
contents : Wave file header I/O

*************************************************************************/

/*************************************************************************
 *
 * Modifications:
 *
 * 11/11/2003, Tilman Liebchen <liebchen@nue.tu-berlin.de>
 *   added support for AIFF and other file formats
 *   - added GetAiffFormat() and helper functions
 *   - added void [Write/Read]U[Short/Long]MSBfirst() functions
 *
 * 1/26/2005, Noboru Harada <n-harada@theory.brl.ntt.co.jp>
 *   added support unknown chunks for wave files generated by Cubase
 *
 * 4/11/2006, Noboru Harada <n-harada@theory.brl.ntt.co.jp>
 *   added support unknown chunks for aiff files generated by ProTools
 *
 * 5/23/2007, Koichi Sugiura <koichi.sugiura@ntt-at.co.jp>
 *   - supported 64-bit data size.
 *   - supported Sony Wave64 and BWF with RF64 formats.
 *
 * 5/14/2008, Koichi Sugiura <koichi.sugiura@ntt-at.co.jp>
 *   - added ReadWaveFormat().
 *   - supported WAVEFORMATEXTENSIBLE.
 *
 * 28/11/2008, Csaba Kos <csaba.kos@ex.ssh.ntt-at.co.jp>
 *   - replaced strcpy calls with memcpy to prevent compiler warning.
 *
 *************************************************************************/

#include <stdio.h>
#include <string.h>

#include "wave.h"
#include "stream.h"

ALS_INT64 GetWaveFormatPCM(HALSSTREAM wav, WAVEFORMATPCM *wf, ALS_INT64 *samples)
{
	char RiffChunkRef[4] = {'R', 'I', 'F', 'F'};
	char WaveChunkRef[4] = {'W', 'A', 'V', 'E'};
	char FormChunkRef[4] = {'f', 'm', 't', ' '};
	char DataChunkRef[4] = {'d', 'a', 't', 'a'};

	char RiffChunk[4], WaveChunk[4];
	char ChunkBuf[4];
	ALS_INT64 RiffLen, FormLen, DataLen, ChunkLen, ChunkLenSum, i;

	// Read file header

	// 'RIFF'
	fread(RiffChunk, 1, 4, wav);
	if (memcmp(RiffChunk, RiffChunkRef, 4) != 0)
		return(-1);
	RiffLen = ReadUIntLSBfirst(wav);

	// 'WAVE'
	fread(WaveChunk, 1, 4, wav);
	if (memcmp(WaveChunk, WaveChunkRef, 4) != 0)
		return(-2);

	// 'fmt '
	//fread(FormChunk, 1, 4, wav);
	ChunkLenSum = FormLen = 0;
	fread(ChunkBuf, 1, 4, wav);
	while(memcmp(ChunkBuf, DataChunkRef, 4) != 0) {
		if (memcmp(ChunkBuf, FormChunkRef, 4) != 0) {
			//unknown chank befor fmt
			ChunkLen = ReadUIntLSBfirst(wav);
			for(i=0;i<ChunkLen;i++)
				fread(ChunkBuf, 1, 1, wav);
			ChunkLenSum += (ChunkLen + 8);
			fread(ChunkBuf, 1, 4, wav);
		} else {
			FormLen = ReadUIntLSBfirst(wav);
			if ( !ReadWaveFormat( wav, wf, FormLen ) ) return (-3);
			fread(ChunkBuf, 1, 4, wav);
		}
	}

	// 'data'
	//fread(DataChunk, 1, 4, wav);
	DataLen = ReadUIntLSBfirst(wav);
	if (memcmp(ChunkBuf, DataChunkRef, 4) != 0)	// Additional unknown chunk
	{
		fseek(wav, DataLen, SEEK_CUR);
		FormLen += DataLen + 8;					// Add size of unknown chunk
		fread(ChunkBuf, 1, 4, wav);
		DataLen = ReadUIntLSBfirst(wav);
		if (memcmp(ChunkBuf, DataChunkRef, 4) != 0)
			return(-5);
	}

	*samples = DataLen / wf->BlockAlign;		// Samples (per channel)

	return(FormLen + ChunkLenSum + 28);			// Length of header (in bytes)
}

short WriteWaveHeaderPCM(HALSSTREAM wav, WAVEFORMATPCM *wf, UINT *samples)
{
	WAVEFILEHEADER header;
	UINT size;

	size = *samples * wf->BlockAlign;	// Size of samples (bytes)
	
	// Generate header
	memcpy(header.RiffChunk, "RIFF", 4);
	header.RiffLen = size + sizeof(header) - 8;
	memcpy(header.WaveChunk, "WAVE", 4) ;
	memcpy(header.FormChunk, "fmt ", 4) ;
	header.FormLen = 16 ;
	header.FormatTag = wf->FormatTag;
	header.Channels = wf->Channels;
	header.SamplesPerSec = wf->SamplesPerSec;
	header.AvgBytesPerSec = wf->AvgBytesPerSec;
	header.BlockAlign = wf->BlockAlign;
	header.BitsPerSample = wf->BitsPerSample;
	memcpy(header.DataChunk, "data", 4);
	header.DataLen = size;

	// Write header
	fwrite(&header, sizeof(header), 1, wav) ;

	return(0);
}

void WriteUShortLSBfirst(unsigned short x, HALSSTREAM fp)
{
	unsigned char tmp[2];

	tmp[1] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[0] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 2, fp);
}

void WriteUShortMSBfirst(unsigned short x, HALSSTREAM fp)
{
	unsigned char tmp[2];

	tmp[0] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[1] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 2, fp);
}

unsigned short ReadUShortLSBfirst(HALSSTREAM fp)
{
	unsigned char tmp[2];

	fread(tmp, 1, 2, fp);

	return(((unsigned short)tmp[1] << 8) + (unsigned short)tmp[0]);
}

unsigned short ReadUShortMSBfirst(HALSSTREAM fp)
{
	unsigned char tmp[2];

	fread(tmp, 1, 2, fp);

	return(((unsigned short)tmp[0] << 8) + (unsigned short)tmp[1]);
}

void WriteUIntLSBfirst(unsigned int x, HALSSTREAM fp)
{
	unsigned char tmp[4];

	tmp[3] = (unsigned char)((x & 0xFF000000) >> 24);
	tmp[2] = (unsigned char)((x & 0x00FF0000) >> 16);
	tmp[1] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[0] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 4, fp);
}

void WriteUIntMSBfirst(unsigned int x, HALSSTREAM fp)
{
	unsigned char tmp[4];

	tmp[0] = (unsigned char)((x & 0xFF000000) >> 24);
	tmp[1] = (unsigned char)((x & 0x00FF0000) >> 16);
	tmp[2] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[3] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 4, fp);
}

unsigned int ReadUIntLSBfirst(HALSSTREAM fp)
{
	unsigned char tmp[4];

	fread(tmp, 1, 4, fp);

	return(((unsigned int)tmp[3] << 24) + ((unsigned int)tmp[2] << 16)
		+ ((unsigned int)tmp[1] << 8) + (unsigned int)tmp[0]);
}

unsigned int ReadUIntMSBfirst(HALSSTREAM fp)
{
	unsigned char tmp[4];

	fread(tmp, 1, 4, fp);

	return(((unsigned int)tmp[0] << 24) + ((unsigned int)tmp[1] << 16)
		+ ((unsigned int)tmp[2] << 8) + (unsigned int)tmp[3]);
}

void WriteUINT64LSBfirst(ALS_UINT64 x, HALSSTREAM fp)
{
	unsigned char tmp[8];

	tmp[7] = (unsigned char)(((x >> 32) & 0xFF000000) >> 24);
	tmp[6] = (unsigned char)(((x >> 32) & 0x00FF0000) >> 16);
	tmp[5] = (unsigned char)(((x >> 32) & 0x0000FF00) >> 8);
	tmp[4] = (unsigned char) ((x >> 32) & 0x000000FF);
	tmp[3] = (unsigned char)((x & 0xFF000000) >> 24);
	tmp[2] = (unsigned char)((x & 0x00FF0000) >> 16);
	tmp[1] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[0] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 8, fp);
}

void WriteUINT64MSBfirst(ALS_UINT64 x, HALSSTREAM fp)
{
	unsigned char tmp[8];

	tmp[0] = (unsigned char)(((x >> 32) & 0xFF000000) >> 24);
	tmp[1] = (unsigned char)(((x >> 32) & 0x00FF0000) >> 16);
	tmp[2] = (unsigned char)(((x >> 32) & 0x0000FF00) >> 8);
	tmp[3] = (unsigned char) ((x >> 32) & 0x000000FF);
	tmp[4] = (unsigned char)((x & 0xFF000000) >> 24);
	tmp[5] = (unsigned char)((x & 0x00FF0000) >> 16);
	tmp[6] = (unsigned char)((x & 0x0000FF00) >> 8);
	tmp[7] = (unsigned char) (x & 0x000000FF);

	fwrite(tmp, 1, 8, fp);
}

ALS_UINT64 ReadUINT64LSBfirst(HALSSTREAM fp)
{
	unsigned char tmp[8];

	fread(tmp, 1, 8, fp);

	return(((ALS_UINT64)tmp[7] << 56) + ((ALS_UINT64)tmp[6] << 48)
		 + ((ALS_UINT64)tmp[5] << 40) + ((ALS_UINT64)tmp[4] << 32)
		 + ((ALS_UINT64)tmp[3] << 24) + ((ALS_UINT64)tmp[2] << 16)
		 + ((ALS_UINT64)tmp[1] << 8) + (ALS_UINT64)tmp[0]);
}

ALS_UINT64 ReadUINT64MSBfirst(HALSSTREAM fp)
{
	unsigned char tmp[8];

	fread(tmp, 1, 8, fp);

	return(((ALS_UINT64)tmp[0] << 56) + ((ALS_UINT64)tmp[1] << 48)
		 + ((ALS_UINT64)tmp[2] << 40) + ((ALS_UINT64)tmp[3] << 32)
		 + ((ALS_UINT64)tmp[4] << 24) + ((ALS_UINT64)tmp[5] << 16)
		 + ((ALS_UINT64)tmp[6] << 8) + (ALS_UINT64)tmp[7]);
}

void FlipLong(unsigned char * ptr)
{
   register unsigned char val;

   /* Swap 1st and 4th bytes */
   val = *(ptr);
   *(ptr) = *(ptr+3);
   *(ptr+3) = val;

   /* Swap 2nd and 3rd bytes */
   ptr += 1;
   val = *(ptr);
   *(ptr) = *(ptr+1);
   *(ptr+1) = val;
}

unsigned int ConvertFloat(unsigned char *buffer)
{
	unsigned int mantissa;
	unsigned int last = 0;
	unsigned char exp;

	FlipLong(buffer+2);

	mantissa = *((unsigned int *)(buffer+2));
	exp = 30 - *(buffer+1);
	while (exp--)
	{
		last = mantissa;
		mantissa >>= 1;
	}
	if (last & 0x00000001)
		mantissa++;

	return(mantissa);
}

ALS_INT64 GetAiffFormat(HALSSTREAM aif, AIFFCOMMON *ac, ALS_INT64 *Offset, ALS_INT64 *BlockSize, UINT *samplerate)
{
	char FormChunkRef[4] = {'F', 'O', 'R', 'M'};
	char AiffChunkRef[4] = {'A', 'I', 'F', 'F'};
	char CommChunkRef[4] = {'C', 'O', 'M', 'M'};
	char SsndChunkRef[4] = {'S', 'S', 'N', 'D'};
	char FormChunk[4], AiffChunk[4], CommChunk[4], ChunkBuf[4];
	ALS_INT64 FormLen, CommLen, SsndLen, ChunkLen, ChunkLenSum, i;

	// Read file header
	// 'FORM'
	fread(FormChunk, 1, 4, aif);
	if (memcmp(FormChunk, FormChunkRef, 4) != 0)
		return(-1);
	FormLen = ReadUIntMSBfirst(aif);

	// 'AIFF'
	fread(AiffChunk, 1, 4, aif);
	if (memcmp(AiffChunk, AiffChunkRef, 4) != 0)
		return(-2);

	// 'COMM'
	fread(CommChunk, 1, 4, aif);
	if (memcmp(CommChunk, CommChunkRef, 4) != 0)
		return(-3);
	CommLen = ReadUIntMSBfirst(aif);

	// AIFFCOMMON
	ac->Channels = ReadUShortMSBfirst(aif);
	ac->SampleFrames = ReadUIntMSBfirst(aif);
	ac->SampleSize = ReadUShortMSBfirst(aif);
	fread(ac->SampleRate, 1, 10, aif);

	if (CommLen > 18)
		fseek(aif, CommLen - 18, SEEK_CUR);

	// 'SSND'
	ChunkLenSum = FormLen = 0;
	fread(ChunkBuf, 1, 4, aif);
	while(memcmp(ChunkBuf, SsndChunkRef, 4) != 0) {
		// unknown chunk before SsndChunk
		ChunkLen = ReadUIntMSBfirst(aif);
		for(i=0;i<ChunkLen;i++)
			fread(ChunkBuf, 1, 1, aif);
		ChunkLenSum += (ChunkLen + 8);
		if(0==fread(ChunkBuf, 1, 4, aif))
			return(-5);
	}

	//fread(SsndChunk, 1, 4, aif);
	SsndLen = ReadUIntMSBfirst(aif);
	if (memcmp(ChunkBuf, SsndChunkRef, 4) != 0)
		return(-5);
	*Offset = ReadUIntMSBfirst(aif);
	*BlockSize = ReadUIntMSBfirst(aif);

	// Convert sample rate value from 80-bit float to unsigned int
	BYTE *buffer = ac->SampleRate;

#if !defined (__BIG_ENDIAN__)
	// Swap 1st <-> 4th and 2nd <-> 3rd bytes
	BYTE *ptr = buffer + 2;
	BYTE val = *(ptr);
	*(ptr) = *(ptr+3);
	 *(ptr+3) = val;
	ptr += 1;
	val = *(ptr); 
	*(ptr) = *(ptr+1);
	*(ptr+1) = val;
#endif

	UINT last = 0;
	UINT mantissa = *((unsigned int *)(buffer+2));
	BYTE exp = 30 - *(buffer+1);
	while (exp--)
	{
		last = mantissa;
		mantissa >>= 1;
	}
	if (last & 0x00000001)
		mantissa++;

	*samplerate = mantissa;				// Sample rate in Hz		

	return(CommLen + ChunkLenSum + 36);	// Length of header (in bytes)
}

ALS_INT64 GetWave64FormatPCM( HALSSTREAM wav, WAVEFORMATPCM* wf, ALS_INT64* samples )
{
	static	const unsigned char	RiffChunkGuid[16] = { 0x72, 0x69, 0x66, 0x66, 0x2E, 0x91, 0xCF, 0x11, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 };
	static	const unsigned char	WaveChunkGuid[16] = { 0x77, 0x61, 0x76, 0x65, 0xF3, 0xAC, 0xD3, 0x11, 0x8C, 0xD1, 0x00, 0xC0, 0x4F, 0x8E, 0xDB, 0x8A };
	static	const unsigned char	FormChunkGuid[16] = { 0x66, 0x6D, 0x74, 0x20, 0xF3, 0xAC, 0xD3, 0x11, 0x8C, 0xD1, 0x00, 0xC0, 0x4F, 0x8E, 0xDB, 0x8A };
	static	const unsigned char	DataChunkGuid[16] = { 0x64, 0x61, 0x74, 0x61, 0xF3, 0xAC, 0xD3, 0x11, 0x8C, 0xD1, 0x00, 0xC0, 0x4F, 0x8E, 0xDB, 0x8A };

	unsigned char	ChunkBuf[16];
	ALS_INT64		ChunkLen, Pos;
	bool			bReadFormChunk = false;

	try {
		// Read file header

		// "RIFF"
		if ( fread( ChunkBuf, sizeof(ChunkBuf), 1, wav ) != 1 ) throw false;
		if ( memcmp( ChunkBuf, &RiffChunkGuid, sizeof(ChunkBuf) ) != 0 ) throw false;
		// Skip dummy RIFF length.
		if ( fseek( wav, sizeof(ALS_INT64), SEEK_CUR ) ) throw false;

		// "WAVE"
		if ( fread( ChunkBuf, sizeof(ChunkBuf), 1, wav ) != 1 ) throw false;
		if ( memcmp( ChunkBuf, &WaveChunkGuid, sizeof(ChunkBuf) ) != 0 ) throw false;

		// "fmt "
		if ( fread( ChunkBuf, sizeof(ChunkBuf), 1, wav ) != 1 ) throw false;

        while ( memcmp( ChunkBuf, &DataChunkGuid, sizeof(ChunkBuf) ) != 0 ) {
			if ( memcmp( ChunkBuf, &FormChunkGuid, sizeof(ChunkBuf) ) != 0 ) {

				// Pass through all the chunks but "fmt ".
				ChunkLen = ReadUINT64LSBfirst( wav );

				// Because all chunks are byte-aligned on 8-byte boundaries,
				// less bytes than multiples of 8-byte of ChunkLen need to be padded.
				ChunkLen += ( ChunkLen & 0x7 ) ? ( 8 - ( ChunkLen & 0x7 ) ) : 0;

				// Skip the chunk contents.
				if ( fseek( wav, ChunkLen - sizeof(ChunkBuf) - sizeof(ALS_INT64) , SEEK_CUR ) ) throw false;
			}
			else {
				if ( bReadFormChunk ) throw false;	// 2 fmt chunks found!

				// Get FormChunk length
				ChunkLen = ReadUINT64LSBfirst( wav );
				if ( ChunkLen < ( sizeof(ChunkBuf) + sizeof(ALS_INT64) + 16 ) ) throw false;
				ChunkLen -= sizeof(ChunkBuf) + sizeof(ALS_INT64);

				if ( !ReadWaveFormat( wav, wf, ChunkLen ) ) throw false;

				// byte-aligned on 8-byte boundaries.
				Pos = ftell( wav );
				if ( Pos & 0x7 ) {
					if ( fseek( wav, 8 - ( Pos & 0x7 ), SEEK_CUR ) ) throw false;
				}

				bReadFormChunk = true;
			}
			// Read the next Chunk
			if ( fread( ChunkBuf, sizeof(ChunkBuf), 1, wav ) != 1 ) throw false;
		}
		// Throw exception if "fmt " chunk doesn't exist.
		if ( !bReadFormChunk ) throw false;

		// Get DATAChunk length
		ChunkLen = ReadUINT64LSBfirst( wav );

		// Samples ( per channel )
		if ( wf->BlockAlign == 0 ) throw false;
		*samples = ( ChunkLen - sizeof(ChunkBuf) - sizeof(ALS_INT64) ) / wf->BlockAlign;

		return ftell( wav );
	}
	catch ( bool ) {
		return -1;
	}
}

ALS_INT64 GetRF64FormatPCM( HALSSTREAM wav, WAVEFORMATPCM* wf, ALS_INT64* samples )
{
	static const char	Rf64ChunkRef[4] = { 'R', 'F', '6', '4' };
	static const char	WaveChunkRef[4] = { 'W', 'A', 'V', 'E' };
	static const char	Ds64ChunkRef[4] = { 'd', 's', '6', '4' };
	static const char	FormChunkRef[4] = { 'f', 'm', 't', ' ' };
	static const char	DataChunkRef[4] = { 'd', 'a', 't', 'a' };

	char		ChunkBuf[4];
	UINT		ChunkLen;
	bool		bReadFormChunk = false;

	try {
		// Read file header

		// "RF64"
		if ( fread( ChunkBuf, 1, 4, wav ) != 4 )		throw false;
		if ( memcmp( ChunkBuf, Rf64ChunkRef, 4 ) != 0 )	throw false;
		if ( ReadUIntLSBfirst( wav ) != 0xFFFFFFFF )	throw false;

		// "WAVE"
		if ( fread( ChunkBuf, 1, 4, wav ) != 4 )		throw false;
		if ( memcmp( ChunkBuf, WaveChunkRef, 4 ) != 0 )	throw false;

		// "ds64"
		if ( fread( ChunkBuf, 1, 4, wav ) != 4 )		throw false;
		if ( memcmp( ChunkBuf, Ds64ChunkRef, 4 ) != 0 )	throw false;

		// Skip 1 UINT and 2 ALS_UINT64's.
		if ( fseek( wav, sizeof(UINT) + sizeof(ALS_UINT64) * 2, SEEK_CUR ) ) throw false;
		// Get number of samples from RIFF64 file header.
		if ( ( *samples	= ReadUINT64LSBfirst( wav ) ) == 0 ) throw false;
		// Get table length, and set file pointer forward.
		ChunkLen = ReadUIntLSBfirst( wav );
		if ( fseek( wav, ChunkLen, SEEK_CUR ) ) throw false;

		// "fmt "
		if ( fread( ChunkBuf, 1, 4, wav ) != 4 ) throw false;
        while ( memcmp( ChunkBuf, DataChunkRef, 4 ) != 0 ) {
			if ( memcmp( ChunkBuf, FormChunkRef, 4 ) != 0 ) {
				// Pass through all the chunks but "fmt "
				ChunkLen = ReadUIntLSBfirst( wav );
				if ( fseek( wav, ChunkLen, SEEK_CUR ) ) throw false;
			}
			else {
				if ( bReadFormChunk ) throw false;	// 2 fmt chunks found!

				// Get FormChunk length
				ChunkLen = ReadUIntLSBfirst( wav );
				if ( ChunkLen < 16 ) throw false;

				if ( !ReadWaveFormat( wav, wf, ChunkLen ) ) throw false;
				bReadFormChunk = true;
			}
			// Read the next Chunk
			if ( fread( ChunkBuf, 1, 4, wav ) != 4 ) throw false;
		}
		// Throw exception if "fmt " chunk doesn't exist.
		if ( !bReadFormChunk ) throw false;

		// Check the "data" chunk size is 0xFFFFFFFF.
		if ( ReadUIntLSBfirst( wav ) != 0xFFFFFFFF ) throw false;

		return ftell( wav );
	}
	catch ( bool ) {
		return -1;
	}
}

bool	ReadWaveFormat( HALSSTREAM wav, WAVEFORMATPCM* pFmt, ALS_INT64 FmtLen )
{
	USHORT		cbSize;
	BYTE		SubFormat[16];
	static const BYTE	SubFormatPCM[16]   = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 };
	static const BYTE	SubFormatFloat[16] = { 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 };

	// Read fmt length.
	if ( FmtLen < 16 ) return false;

	// Read common fields for PCMWAVEFORMAT, WAVEFORMATEX and WAVEFORMATEXTENSIBLE.
	pFmt->FormatTag      = ReadUShortLSBfirst( wav );
	pFmt->Channels       = ReadUShortLSBfirst( wav );
	pFmt->SamplesPerSec  = ReadUIntLSBfirst( wav );
	pFmt->AvgBytesPerSec = ReadUIntLSBfirst( wav );
	pFmt->BlockAlign     = ReadUShortLSBfirst( wav );
	pFmt->BitsPerSample  = ReadUShortLSBfirst( wav );
	pFmt->ValidBitsPerSample = pFmt->BitsPerSample;

	// Check the fmt length.
	if ( FmtLen >= 16 + 2 ) {
		// Read cbSize.
		cbSize = ReadUShortLSBfirst( wav );
		if ( FmtLen != 16 + 2 + cbSize ) return false;
		if ( pFmt->FormatTag == 0xfffe ) {	// WAVEFORMATEXTENSIBLE
			// Read wValidBitsPerSample.
			pFmt->ValidBitsPerSample = ReadUShortLSBfirst( wav );
			// Skip dwChannelMask.
			ReadUIntLSBfirst( wav );
			// Read SubFormat.
			if ( fread( SubFormat, 1, 16, wav ) != 16 ) return false;
			if ( memcmp( SubFormat, SubFormatPCM, 16 ) == 0 ) pFmt->FormatTag = 1;
			else if ( memcmp( SubFormat, SubFormatFloat, 16 ) == 0 ) pFmt->FormatTag = 3;
			else return false;
			cbSize -= 22;
		}
		// Skip extra data, if exists.
		if ( cbSize > 0 ) fseek( wav, cbSize, SEEK_CUR );
	}

	// Check FormatTag.
	if ( ( pFmt->FormatTag != 1 ) && ( pFmt->FormatTag != 3 ) ) return false;
	return true;
}
